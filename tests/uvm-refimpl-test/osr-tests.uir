// requires "primitives.uir"

.funcsig @v_i = @void (@i64)

.funcdef @intro_test_base VERSION @intro_test_base_v1 <@v_i> {
    %entry(<@i64> %n):
        %rv = CALL <@v_i> @intro_rec (%n)
        
        COMMINST @uvm.thread_exit
}

.funcdef @intro_rec VERSION @intro_rec_v1 <@v_i> {
    %entry(<@i64> %n):
        %isz = EQ <@i64> %n @I64_0
        BRANCH2 %isz %zero(%n) %nz(%n)

    %zero(<@i64> %n):
        %trap_rec = TRAP <@i64> KEEPALIVE(%n)
        RET %trap_rec

    %nz(<@i64> %n):
        %nm1 = SUB <@i64> %n @I64_1
        %rv = CALL <@v_i> @intro_rec (%nm1) KEEPALIVE(%n %nm1)

        RET %rv
}

.funcdef @osr_test_base VERSION @osr_test_base_v1 <@v_i> {
    %entry(<@i64> %n):
        %rv = CALL <@i_i> @sum (%n)
        %trap_base_exit = TRAP <@void> KEEPALIVE (%rv)
        COMMINST @uvm.thread_exit
}

.const @sum_v1.THRESHOLD <@i64> = 5

// Sum from 0..(n-1), but optimise when adding more than 5 numbers
.funcdef @sum VERSION @sum_v1 <@i_i> {
    %entry(<@i64> %n):
        BRANCH %head(%n @I64_0 @I64_0)

    %head(<@i64> %n <@i64> %i <@i64> %s):
        %ge_thr = SGE <@i64> %i @sum_v1.THRESHOLD
        BRANCH2 %ge_thr %opt(%n %i %s) %head2(%n %i %s)

    %head2(<@i64> %n <@i64> %i <@i64> %s):
        %lt_n = SLT <@i64> %i %n
        BRANCH2 %lt_n %body(%n %i %s) %exit(%s)

    %body(<@i64> %n <@i64> %i <@i64> %s):
        %i2 = ADD <@i64> %i @I64_1
        %s2 = ADD <@i64> %s %i
        BRANCH %head(%n %i2 %s2)

    %exit(<@i64> %s):
        RET %s

    %opt(<@i64> %n <@i64> %i <@i64> %s):
        %trap_opt = TRAP <@void> KEEPALIVE(%n %i %s)
        THROW @NULLREF // unreachable
}
